type GeneralIdFormat = string;
export type UserId = GeneralIdFormat;

export const enum USER_KEY_STORAGE_NAMES
{
	userData = "user_data",
	actualUser = "actual_user",

	userPublicData = "user_public_data",
	userPublicKey = "user_public_key",
	userVerifyKey = "user_verify_key",

	groupData = "group_data"
}

export interface UserData
{
	private_key:string,
	public_key: string,
	sign_key: string,
	verify_key: string,
	exported_public_key: string,
	exported_verify_key: string,
	jwt: string,
	refresh_token: string,
	user_id: string
}

export interface GroupKey {
	private_group_key: string,
	public_group_key: string,
	group_key: string,
	time: string,
	group_key_id: string
}

export interface GroupOutDataKeys {
	private_key_id: string,
	key_data: string
}

export interface GroupData
{
	group_id: string,
	parent_group_id: string,
	from_parent: boolean,	//describe if this group was fetched by parent group or normal fetch
	rank: number,
	key_update:boolean,
	create_time: string,
	joined_time: string,
	keys: GroupKey[],
	key_map: Map<string, number>	//save the index of the key to this key id
}

export interface GroupList
{
	group_id: string,
	time: number,
	joined_time: number,
	rank: number,
	parent?: string
}

export interface GroupInviteListItem
{
	group_id: string,
	time: number
}

export interface GroupJoinReqListItem
{
	user_id: string,
	time: number
}

export interface GroupKeyRotationOut
{
	pre_group_key_id: string,
	server_output: string,
	new_group_key_id: string,
	encrypted_eph_key_key_id: string
}

export interface KeyRotationInput {
	encrypted_ephemeral_key_by_group_key_and_public_key: string,
	encrypted_group_key_by_ephemeral: string,
	ephemeral_alg: string,
	encrypted_eph_key_key_id: string, //the public key id which was used to encrypt the eph key on the server.
	previous_group_key_id: string,
	time: string,
	new_group_key_id: string,
}

export interface GroupUserListItem {
	user_id: string,
	rank: number,
	joined_time: number,
}

//______________________________________________________________________________________________________________________

export interface SignHead {
	id: string,
	alg: string
}

export interface CryptoHead {
	id: string,
	sign: SignHead | undefined
}

export interface CryptoRawOutput
{
	head: string,
	data: Uint8Array
}

//______________________________________________________________________________________________________________________

/**
 * The data is an array
 *
 * in each element there is the data for each attachment file type. these elements are arrays too
 * e.g.: all [img files, all videos files] etc
 *
 * in each file type array there are arrays about the actual content
 * e.g. uploading 2 img and 1 video:
 *
 * [
 * 	[img_1, img_2],
 * 	[video_1]
 * ]
 *
 * this is because the session data is generated by the different attachment models for each type
 */
export type AttachmentSessionData = {frontendId: string, sessionId: string}[][];


export interface FileMetaInformation {
	file_id: string,
	belongs_to?: string,
	belongs_to_type: any,
	key_id: string,
	part_list: string[]
}